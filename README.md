# ü§ñ Basic AI Agent - Agente de IA Especializado

[![Python](https://img.shields.io/badge/_Python-3.11+-3776AB?style=for-the-badge&logo=python&logoColor=white)](https://python.org)
[![Pydantic AI](https://img.shields.io/badge/_Pydantic_AI-0.4.2-E92063?style=for-the-badge&logo=pydantic&logoColor=white)](https://ai.pydantic.dev)
[![Gemini](https://img.shields.io/badge/_Google_Gemini-2.5_Pro-4285F4?style=for-the-badge&logo=googlegemini&logoColor=white)](https://ai.google.dev)
[![MCP](https://img.shields.io/badge/Model_Context_Protocol-1.11.0-00D4AA?style=for-the-badge&logo=modelcontextprotocol&logoColor=white)](https://modelcontextprotocol.io)

[![Streamlit](https://img.shields.io/badge/_Streamlit-UX/UI-FF4B4B?style=for-the-badge&logo=streamlit&logoColor=white)](https://streamlit.io)
[![Playwright](https://img.shields.io/badge/_Playwright-Scraping-2EAD33?style=for-the-badge&logo=playwright&logoColor=white)](https://playwright.dev)
[![FastAPI](https://img.shields.io/badge/_FastAPI-0.116.1-009688?style=for-the-badge&logo=fastapi&logoColor=white)](https://fastapi.tiangolo.com)
[![Cloud Storage](https://img.shields.io/badge/Almacenamiento_Temporal-Google_Cloud_Storage-4285F4?style=for-the-badge&logo=googlecloudstorage&logoColor=white)](https://cloud.google.com/storage)

[![Cloud](https://img.shields.io/badge/Cloud-Google_Cloud-4285F4?style=for-the-badge&logo=googlecloud&logoColor=white)](https://cloud.google.com)
[![Logfire](https://img.shields.io/badge/Logfire-Observability-FF6B35?style=for-the-badge)](https://pydantic.dev/logfire)
[![Dotenv](https://img.shields.io/badge/Manejo_de_Secretos-dotenv-ECD53F?style=for-the-badge&logo=dotenv&logoColor=white)](https://pypi.org/project/python-dotenv/)

## üìã Descripci√≥n del Proyecto

**Basic AI Agent** es un proyecto de desarrollo de agentes de inteligencia artificial especializados utilizando **Pydantic AI**. El objetivo principal es crear un ecosistema modular de agentes que puedan especializarse en diferentes dominios de datos regionales y funcionalidades espec√≠ficas.

### üéØ Objetivos del Proyecto

- **Agente General**: Desarrollo de un agente base con capacidades fundamentales
- **Especializaci√≥n Modular**: Creaci√≥n de agentes especializados por dominio
- **Banco de Prompts**: Sistema de gesti√≥n de prompts especializados
- **Banco de Tools**: Biblioteca reutilizable de herramientas
- **Interfaz Streamlit**: Interfaz web para selecci√≥n de agentes especializados
- **Datos Regionales**: Enfoque en informaci√≥n local (Colombia)

### üèóÔ∏è Arquitectura Planificada

```mermaid
graph TD
    A[Usuario] --> B[Interfaz Streamlit]
    B --> C{Selector de Agentes}
    
    C --> D[Agente General]
    C --> E[Agente Noticias]
    C --> F[Agente Inmobiliario]
    C --> G[Agente Financiero]
    
    D --> H[Banco de Prompts]
    E --> H
    F --> H
    G --> H
    
    D --> I[Banco de Tools]
    E --> I
    F --> I
    G --> I
    
    I --> J[Tool: Tiempo]
    I --> K[Tool: Noticias]
    I --> L[MCP: Inmobiliaria]
    I --> M[Tool: An√°lisis Multimedia]
    
    M --> N[Subagente Multimedia]
    N --> O[An√°lisis Im√°genes]
    N --> P[An√°lisis Videos]
    N --> Q[An√°lisis Documentos]
    
    D --> R[Gemini 2.5 Pro]
    E --> R
    F --> R
    G --> R
    N --> R
    
    style N fill:#e1f5fe
    style M fill:#fff3e0
    style O fill:#e8f5e8
    style P fill:#e8f5e8
    style Q fill:#e8f5e8
```

## üß† Gesti√≥n Inteligente de Contexto

Una de las caracter√≠sticas principales de este agente es su **ventana de contexto din√°mico** que permite controlar cu√°ntos mensajes anteriores recuerda el agente. Esto es crucial para optimizar tanto el rendimiento como los costos de tokens.

### üéõÔ∏è Ventana de Contexto Din√°mico

![Ventana de Contexto](img/Validacion%20de%20persistencia.png)

El agente cuenta con un control deslizante que permite ajustar la ventana de contexto en tiempo real:

- **Rango**: 1-20 mensajes anteriores
- **Valor por defecto**: 6 mensajes
- **Impacto**: A mayor contexto, mayor consumo de tokens y costo

**‚ö†Ô∏è Importante**: Una ventana de contexto mayor significa m√°s tokens enviados al modelo, lo que incrementa el costo por consulta.

### üíª Implementaci√≥n del Manejo de Historia

#### Ejemplo B√°sico - Solo √öltimo Mensaje
```python
import asyncio
from agent_model import test_agent

async def chat_with_history():
    """ Funci√≥n para mantener el contexto del mensaje anterior"""
    
    history = [] # Definimos la lista para guardar los mensajes
    
    print("Si desea salir escriba 'salir','s' o 'q'")
    # Creamos el bucle
    async with test_agent.run_mcp_servers():
        while True:
            user_input = input("User: ") # Entrada del usuario
            if user_input.lower() in {"salir","s","q"}: # Validamos si quiere salir
                break
            # Preguntamos al modelo
            result = await test_agent.run(user_input, message_history=history)
            print(f"Agent: {result.output}") # Obtenemos la respuesta
            
            history = result.new_messages() # Agregamos el mensaje al historial
            # Nota: el agente solo tendr√° contexto del √∫ltimo mensaje
        
if __name__ == "__main__":
    asyncio.run(chat_with_history())
```

#### Opciones de Manejo de Historia

**Para obtener TODO el historial:**
```python
history = result.all_messages()  # Mantiene todos los mensajes
```

**Para una ventana de contexto personalizada (implementaci√≥n en app.py):**
```python
# Numero de mensajes que recuerda
contexto = 6 

# Ventana de contexto din√°mico
MAX_HISTORY = (contexto * 3) + 1

# Obtenemos todo el historial acumulado
all_msgs = result.all_messages()

# Recortamos los √∫ltimos N mensajes usando slicing
trimmed_history = all_msgs[-MAX_HISTORY:]

# Actualizamos el historial
history = trimmed_history

```

### üìù **Explicaci√≥n de la F√≥rmula `MAX_HISTORY`**

La f√≥rmula `MAX_HISTORY = (contexto * 3) + 1` se basa en c√≥mo **Pydantic AI** estructura internamente los mensajes:

#### üîç **Anatom√≠a de un Intercambio en Pydantic AI:**

Para cada interacci√≥n usuario-agente, Pydantic AI genera **3 mensajes**:
1. **Mensaje del Usuario** üìù - La pregunta o solicitud
2. **Llamada a Herramientas** üõ†Ô∏è - Si el agente usa tools (tiempo, noticias, MCP, etc.)
3. **Respuesta del Agente** ü§ñ - La respuesta final procesada

#### üßÆ **Desglose del C√°lculo:**
- **`contexto * 3`**: Multiplica por 3 para incluir los 3 tipos de mensaje por cada intercambio
- **`+ 1`**: Suma 1 para incluir el **System Prompt** inicial que establece las instrucciones base del agente

#### üí° **Ejemplo Pr√°ctico:**
```
contexto = 6 mensajes anteriores
MAX_HISTORY = (6 * 3) + 1 = 19 mensajes totales

Distribuci√≥n:
- 1 System Prompt inicial
- 18 mensajes de 6 intercambios (6 √ó 3)
  ‚Ä¢ 6 preguntas del usuario
  ‚Ä¢ 6 llamadas a herramientas  
  ‚Ä¢ 6 respuestas del agente
```

Esta estructura garantiza que el agente mantenga el contexto completo de las conversaciones anteriores sin perder informaci√≥n crucial sobre las herramientas utilizadas en cada intercambio.

### üîÑ Beneficios del Sistema de Contexto

- **üí∞ Control de Costos**: Ajusta el consumo de tokens seg√∫n necesidades
- **‚ö° Performance**: Menor contexto = respuestas m√°s r√°pidas
- **üéØ Relevancia**: Mantiene solo informaci√≥n contextual relevante
- **üîß Flexibilidad**: Configuraci√≥n din√°mica durante la conversaci√≥n

## üìÅ Sistema de Gesti√≥n de Archivos con GCP Storage

El proyecto incluye una **funcionalidad avanzada de gesti√≥n de archivos** que permite a los usuarios subir archivos directamente a **Google Cloud Storage** y generar URLs p√∫blicas para que los agentes especializados puedan analizarlos. Esta implementaci√≥n elimina las limitaciones de tama√±o y permite un procesamiento m√°s eficiente de contenido multimedia.

### üîß Arquitectura de Subida de Archivos

```mermaid
graph TD
    A[Usuario] --> B[Interfaz Streamlit]
    B --> C[File Uploader]
    C --> D[Validaci√≥n de Archivo]
    D --> E[Google Cloud Storage]
    E --> F[Bucket: multi_ai_agent]
    F --> G[Generar URL P√∫blica]
    G --> H[Agente Principal]
    H --> I[Tool: read_media]
    I --> J[Subagente Multimedia]
    J --> K[An√°lisis del Archivo]
    K --> L[Respuesta al Usuario]
    
    style E fill:#4285F4
    style F fill:#34A853
    style G fill:#EA4335
```

### üì∏ Proceso Visual de Subida y An√°lisis

<div align="center">

| Archivo en GCP | Generaci√≥n de URL |
|:-------------:|:----------------:|
| ![Archivo subido en GCP](img/Archivo_subido_en_GCP.jpg) | ![Generaci√≥n link uso](img/Generacion_link_uso.png) |

</div>

![Adjuntar archivo](img/Adjuntar_archivo.png)

<div align="center">

| Respuesta del Agente |
|:-------------------:|
| ![Respuesta al archivo adjunto](img/Respuesta_al_archivo_adjunto.png) |

</div>

### üíª Implementaci√≥n GCP Storage

```python
import os
from dotenv import load_dotenv
from google.cloud import storage
from google.cloud.exceptions import NotFound

load_dotenv()

json_gcp = os.getenv("JSON_GCP")
client = storage.Client.from_service_account_json(json_gcp)

def save_in_bucket(file_name:str ,file: any ,bucket_name:str ="multi_ai_agent"):
    try: 
        bucket = client.get_bucket(bucket_name)
    except NotFound as e:
        raise RuntimeError(f"Bucket {bucket_name} no encontrado : {e}")
    
    blob = bucket.blob(file_name)
    blob.upload_from_file(file, content_type=file.type)
    blob.make_public()
    
    return blob.public_url

def drop_file(file_name: str, bucket_name:str ="multi_ai_agent"):
    try: 
        bucket = client.get_bucket(bucket_name)
    except NotFound as e:
        raise RuntimeError(f"Bucket {bucket_name} no encontrado : {e}")
    
    blob = bucket.blob(file_name)
    
    if not blob.exists():
        return {"status": False, "message": f"Archivo no existe: {file_name}"}
    
    blob.delete()
    return True
```

### üöÄ Caracter√≠sticas del Sistema de Archivos

- **‚òÅÔ∏è Almacenamiento en la Nube**: Integraci√≥n directa con Google Cloud Storage
- **üîó URLs P√∫blicas**: Generaci√≥n autom√°tica de enlaces p√∫blicos accesibles
- **üóëÔ∏è Gesti√≥n Completa**: Funciones de subida y eliminaci√≥n de archivos
- **üîí Seguridad**: Manejo de credenciales mediante variables de entorno
- **üéØ Integraci√≥n Directa**: Los agentes pueden acceder inmediatamente al contenido

### üìã Formatos de Archivo Soportados

| Categor√≠a | Formatos | Capacidades |
|-----------|----------|-------------|
| **üì∑ Im√°genes** | JPG, PNG, GIF, WebP | An√°lisis visual, OCR, detecci√≥n de objetos |
| **üé• Videos** | MP4, AVI, MOV, WebM | An√°lisis de contenido, transcripci√≥n |
| **üìÑ Documentos** | PDF, DOC, DOCX, TXT | Extracci√≥n de texto, an√°lisis de contenido |

## üéØ Sistema de Delegaci√≥n de Tareas con Subagentes

Una de las caracter√≠sticas m√°s avanzadas del proyecto es la **integraci√≥n de delegaci√≥n de tareas** que permite a Pydantic AI crear subagentes especializados para tareas espec√≠ficas. En este caso, se ha implementado un **agente de an√°lisis multimedia** que funciona como herramienta delegada.

### üîß Arquitectura de Delegaci√≥n

![Agente usando subagente como tool](img/Agente%20usando%20subagente%20como%20tool.png)

El sistema funciona con la siguiente arquitectura:

```mermaid
graph TD
    A[Usuario] --> B[Agente Principal]
    B --> C{¬øRequiere an√°lisis multimedia?}
    
    C -->|S√≠| D[Tool: read_media]
    C -->|No| E[Otras herramientas]
    
    D --> F[Subagente Multimedia]
    F --> G[An√°lisis de contenido]
    G --> H[Resultado al agente principal]
    H --> I[Respuesta final al usuario]
    
    E --> I
```

### üé• Implementaci√≥n del Subagente Multimedia

#### Definici√≥n del Subagente Especializado

```python
# Agente especializado en an√°lisis multimedia
media_agent = Agent(
    model=model_config(),
    system_prompt="""
    Eres un agente encargado de analizar URLs y responder en base a las preguntas, 
    puedes recibir URLs de imagen, video o documento; debes analizarlas y responder con precisi√≥n.
    """,
    output_type=ResponseBase
)

# Funci√≥n que act√∫a como herramienta delegada
async def read_media(question: str,
                    media_url: str,
                    type_file: Literal["imagen","video","documento"]) -> str:
    """
    Funci√≥n para analizar archivos multimedia: im√°genes, videos o documentos.
    
    Par√°metros:
    - question: Pregunta a realizar sobre el archivo
    - media_url: URL p√∫blica del archivo a analizar
    - type_file: Tipo de archivo ("imagen", "video", "documento")
    
    Retorna:
    - Respuesta generada por el subagente especializado
    """
    media_type = type_map.get(type_file)
    response = await media_agent.run([question, media_type(media_url)])
    return response.output.response

# Herramienta que encapsula el subagente
read_media_tool = Tool(
    function=read_media,
    name="read_media",
    description="Tool especializada en an√°lisis multimodal (imagen, video, documento) desde URLs p√∫blicas.",
    max_retries=3
)
```

### üèóÔ∏è Integraci√≥n en Agentes Especializados

Todos los agentes especializados incluyen la capacidad de delegaci√≥n multimedia:

```python
def agent_noticias(model) -> Agent:
    return Agent(
        model=model,
        system_prompt=NOTICIAS_SYSTEM_PROMPT,
        tools=[get_time_now_tool, get_news_tool, read_media_tool],  # ‚Üê Delegaci√≥n incluida
        retries=True,
        instrument=True
    )

def agent_inmobiliario(model) -> Agent:
    return Agent(
        model=model,
        system_prompt=INMOBILIARIO_SYSTEM_PROMPT,
        tools=[read_media_tool],  # ‚Üê Capacidad multimedia
        mcp_servers=[inmopipeline_mcp],
        retries=2,
        instrument=True
    )
```

### üíª Flujo de Ejecuci√≥n en Terminal

![Terminal flujo de delegaci√≥n de tareas](img/terminal_flujo_de_delagacion_de_tareas.png)

El flujo de delegaci√≥n se ejecuta de la siguiente manera:

1. **üë§ Usuario**: Solicita an√°lisis de una imagen, video o documento mediante URL
2. **ü§ñ Agente Principal**: Identifica que necesita an√°lisis multimedia
3. **üîß Herramienta read_media**: Se activa autom√°ticamente como delegaci√≥n
4. **üéØ Subagente Multimedia**: Procesa el contenido espec√≠fico
5. **üìä An√°lisis Especializado**: Genera respuesta enfocada en el contenido multimedia
6. **üîÑ Retorno**: El resultado se integra en la respuesta del agente principal
7. **üí¨ Respuesta Unificada**: El usuario recibe una respuesta coherente que combina el an√°lisis multimedia con el contexto de la conversaci√≥n

### üé≠ Capacidades Multimodales Soportadas

| Tipo de Archivo | Formato Pydantic AI | Capacidades de An√°lisis |
|-----------------|-------------------|------------------------|
| **üì∑ Im√°genes** | `ImageUrl` | Descripci√≥n, OCR, detecci√≥n de objetos, an√°lisis visual |
| **üé• Videos** | `VideoUrl` | An√°lisis de contenido, transcripci√≥n, detecci√≥n de escenas |
| **üìÑ Documentos** | `DocumentUrl` | Extracci√≥n de texto, an√°lisis de contenido, resumen |

### üí° Ventajas de la Delegaci√≥n de Tareas

- **üéØ Especializaci√≥n**: Cada subagente se enfoca en una tarea espec√≠fica
- **üîÑ Reutilizaci√≥n**: La herramienta multimedia puede ser usada por cualquier agente
- **‚ö° Eficiencia**: Procesamiento optimizado seg√∫n el tipo de contenido
- **üõ°Ô∏è Modularidad**: F√°cil mantenimiento y escalabilidad del sistema
- **üß† Inteligencia Distribuida**: Divisi√≥n l√≥gica de responsabilidades

### üöÄ Casos de Uso Pr√°cticos

- **üì∞ Agente de Noticias**: Analiza im√°genes de noticias, capturas de pantalla de art√≠culos
- **üè† Agente Inmobiliario**: Examina fotos de propiedades, planos, documentos legales
- **üå§Ô∏è Agente Meteorol√≥gico**: Interpreta mapas clim√°ticos, gr√°ficos meteorol√≥gicos
- **üí∞ Agente Financiero**: Analiza gr√°ficos de bolsa, reportes financieros, tablas de datos

Esta implementaci√≥n demuestra c√≥mo **Pydantic AI** facilita la creaci√≥n de sistemas de IA colaborativos donde diferentes agentes pueden especializarse y trabajar en conjunto para resolver tareas complejas de manera eficiente.

## üõ†Ô∏è Estado Actual del Desarrollo

### ‚úÖ Funcionalidades Implementadas

- **Agente Base**: Configurado con Gemini 2.5 Pro
- **Sistema de Delegaci√≥n**: Subagentes especializados como herramientas
- **Gesti√≥n de Archivos GCP**: Subida autom√°tica a Google Cloud Storage con URLs p√∫blicas
- **An√°lisis Multimedia**: Procesamiento de im√°genes, videos y documentos via URL
- **Sistema de Tools**: 
  - üïê Obtenci√≥n de fecha y hora actual
  - üì∞ Scraping de noticias de El Tiempo
  - üè† Consulta inmobiliaria via MCP
  - üé• An√°lisis multimodal (delegaci√≥n a subagente especializado)
  - üìÅ Gesti√≥n de archivos en la nube (subida/eliminaci√≥n)
- **Esquemas Pydantic**: Validaci√≥n de entrada y salida
- **Observabilidad**: Integraci√≥n con Logfire
- **Arquitectura Modular**: Separaci√≥n de prompts, tools y schemas
- **Interfaz Streamlit**: Selecci√≥n de agentes, gesti√≥n de archivos y configuraci√≥n de rendimiento
- **Gesti√≥n de Contexto**: Ventana din√°mica de historia de conversaci√≥n

### üöß En Desarrollo

- [ ] Agentes especializados por dominio
- [ ] Banco de prompts din√°mico
- [ ] Herramientas adicionales (clima, finanzas)
- [ ] Sistema de configuraci√≥n de agentes

## üöÄ Tecnolog√≠as Utilizadas

### Core Framework
- **Pydantic AI**: Framework principal para agentes de IA
- **Google Gemini 2.5 Pro**: Modelo de lenguaje base
- **Python 3.11+**: Lenguaje de programaci√≥n

### Herramientas y Servicios
- **MCP (Model Context Protocol)**: Para servicios externos
- **Playwright**: Web scraping de noticias
- **Logfire**: Observabilidad y monitoreo
- **AsyncIO**: Programaci√≥n as√≠ncrona
- **Google Cloud Storage**: Almacenamiento de archivos en la nube

### Futuras Integraciones
- **Streamlit**: Interfaz de usuario web

## üéØ Agentes Especializados Planificados

### üì∞ Agente de Noticias
- Fuentes: El Tiempo, El Espectador, Semana
- Categorizaci√≥n autom√°tica
- Res√∫menes personalizados

### üè† Agente Inmobiliario
- Precios de vivienda en Colombia
- An√°lisis de mercado regional
- Recomendaciones de inversi√≥n

### üå§Ô∏è Agente Meteorol√≥gico
- Clima actual y pron√≥sticos
- Alertas meteorol√≥gicas
- Datos regionales espec√≠ficos

### üí∞ Agente Financiero
- Precios de acciones colombianas
- Tasas de cambio COP
- Indicadores econ√≥micos

## üí° Caracter√≠sticas Clave

- **üîß Modularidad**: Arquitectura basada en componentes reutilizables
- **üéØ Delegaci√≥n Inteligente**: Subagentes especializados como herramientas
- **üìÅ Gesti√≥n de Archivos en la Nube**: Subida autom√°tica a GCP Storage con URLs p√∫blicas
- **üé• An√°lisis Multimodal**: Procesamiento de im√°genes, videos y documentos
- **üåé Datos Regionales**: Enfoque en informaci√≥n colombiana
- **üîÑ As√≠ncrono**: Operaciones no bloqueantes
- **üìä Observabilidad**: Monitoreo completo con Logfire
- **üõ°Ô∏è Validaci√≥n**: Esquemas Pydantic para datos seguros
- **üß† Gesti√≥n de Contexto**: Control din√°mico de historia conversacional
- **üé® Interfaz Completa**: Streamlit con capacidades de file upload

## üö¶ Roadmap

### Fase 1: Base (Actual) ‚úÖ
- [x] Agente general funcional
- [x] Herramientas b√°sicas (tiempo, noticias, inmobiliaria)
- [x] Arquitectura modular

### Fase 2: Especializaci√≥n üöß
- [ ] Agentes especializados por dominio
- [ ] Banco de prompts din√°mico
- [ ] M√°s herramientas regionales

### Fase 3: Interfaz üîÆ
- [ ] Interfaz Streamlit
- [ ] Selector de agentes
- [ ] Dashboard de monitoreo

### Fase 4: Escalabilidad üîÆ
- [ ] Base de datos persistente
- [ ] Cache distribuido
- [ ] API REST completa
